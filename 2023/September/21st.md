## 　2023年9月21日(木)
# 【取り組んだ課題一覧】
## ☆Docker
⚫︎Docker入門<br>
・入門 Dockerを読む<br>
→プロダクションでの活用-Dockerfileのベストプラクティス-まで<br>
# 【わかったこと】
『入門 Docker』<br>
[プロダクションでの活用-設計-]
⚫︎1コンテナ = 1プロセス<br>
Dockerは1つのプロセスをフォアグラウンドで走らせるための技術である。基本的に「1コンテナ = 1プロセス」の粒度で設計すること。しかし、基本的にほとんどのケースが「1コンテナ = 1プロセス」で設計できるが、全てのケースが一概に1コンテナ = 1プロセスにできるわけではないためその点は見極めること。<br>
⚫︎永続的なデータはマネージドサービスに任せる<br>
コンテナの設計がわからないうちは「12factor app」(Heroku社が提唱するモダンなサービスを実現するための12の方法論)の12の方法論にのっとり設計を行うと綺麗な環境を構築することができる。<br>
・ステート:機器やソフトウェア、システム、あるいはそれらの取り扱う対象などについて、ある具体的な状況や状態、設定などを値やデータなどで表したもの。<br>
[プロダクションでの活用-セキュリティ-]<br>
⚫︎rootユーザを使わない<br>
Docker Imageのデフォルトがrootユーザのイメージは多いため注意が必要。<br>
USERコマンド使用してユーザーを変更すること。<br>
⚫︎野良のDockerイメージをベースイメージにしない<br>
所謂ユーザー製のイメージをベースイメージとして使うことはリスクである。<br>
基本的にベースイメージは公式のものを使用するようにすること。<br>
⚫︎ビルド時に機微情報を与えない<br>
Dockerのビルドはレイヤー毎にスナップショットがとられ、中間イメージも実行することができる。<br>
どうしてもパスワードや秘密鍵のような機微情報が必要な場合は`--secret`や`--ssh`オプションを使用してセキュアにビルドをすること。また、パスワードや接続情報などは環境変数やVaultなどへ格納すること。<br>
⚫︎ホストのファイルのマウントの仕方<br>
ホストのファイルをマウントする際は十分に注意して最小限の権限とパスで範囲を狭くするようにする。また、特に注意が必要なのはdockerソケットである。近年、CIや監視などでdockerソケットのマウントを要求するソフトウェアが増えてた。安易に与えるのは控え、ソケットをマウントしなければならない場合はRead-Onlyでマウントするようにすること。<br>
・ソケット:各ネットワーク機器が外部とやりとりする際の窓口のこと。<br>
・Dockerソケット:Docker APIとの通信を容易にするUNIXネットワークソケット。<br>
⚫︎.dockerignoreファイルを使う<br>
.dockerignoreファイルはDockerビルド時に無視するパスを記述するファイル。.gitignoreのようなイメージに近い。ビルド時に不要なパスは無視することでビルドが高速かつイメージが軽量になる。<br>
[プロダクションでの活用-デバッグ-]<br>
⚫︎長命なコンテナ<br>
・実行中のコンテナだけを表示したい場合は`-a`オプションを付けないで実行することでフィルタすることができる。<br>
`docker container ls`<br>
⚫︎コンポーネントの削除<br>
・コンテナの停止<br>
`$ docker stop $(docker container ls -q)`<br>
・コンテナの削除<br>
`$ docker rm $(docker container ls -aq)`<br>
・イメージの削除<br>
`$ docker rmi $(docker images -q)`<br>
⚫︎ログを確認する<br>
・`docker logs`:コンテナのログを確認する。<br>
・docker logsで表示されるログは起動したプロセスの標準出力と標準エラーである。ファイルに吐き出されたログはdocker logsコマンドでは基本的に閲覧することはできない。<br>
[プロダクションでの活用-イメージの仕組み-]<br>
⚫︎イメージの仕組み<br>
Docker ImageはDockerfileによって作成される特定の環境のスナップショットである。<br>
そしてそのDocker Imageを実行することでDocker Containerを起動することができる。<br>
⚫︎Container<br>
生成されたDockerImageはRead Onlyである。Docker Containerを作成することで変更可能なレイヤーが新しく作成され、その上でプロセスを動かす。コンテナ起動後、どのファイルが変更されたかはdocker diffを使用して確認することができる。<br>
⚫︎Unison FileSystem<br>
Docker ContainerからDocker Imageへファイルを読み込む際、気をつけないとオーバーヘッドが大きくなる。Containerレイヤーに操作対象のパスが存在しない場合、Imageレイヤーにファイルが無いかの捜査を行う。この捜査は1レイヤーごとに見ていくため、レイヤーが多くなればなるほどオーバーヘッドが大きくなっていく。また、Dockerがデフォルトで使用しているファイルシステムではCopy On Write方式でファイルの読み書きを行う。ファイルの更新がかかる度に捜査を実行するため、ログのように書き込みの激しいパスはDataVolumeを使用してUnison FileSystemを回避すると良い。<br>
⚫︎Dockerイメージ<br>
・Docker Imageは複数のDocker Imageの積み重ねでできている。<br>
・イメージは1つのイメージで完結しているわけではなく、複数のイメージを積み重ねて最終的に1つのイメージになる。積み重ねられたイメージのことを中間イメージと呼ぶ。<br> 
・どのような歴史でイメージがビルドされたかを知るには`docker history`を使用することで可能。<br>
・docker historyで中間イメージにもIMAGEのIDを確認することができる。このIMAGE IDを指定して実行することで、その時点までの実行結果を見ることが可能。<br>
⚫︎レイヤーと中間イメージ<br>
レイヤーと中間イメージは別物である。Dockerfile上でコマンド(EXPOSE, ENV, COPY, etc)を実行するたびに中間イメージが作成される。レイヤーはRUN, COPY, ADDの実行時に増やし、UnisonFileSystemへの影響がある。基本的に、中間イメージではなくレイヤーを増やさないこと意識するのが良い。<br>
⚫︎まとめ<br>
・Dockerイメージは複数のイメージが積み重なったもの。<br>
・Dockerfileの書き方によってファイルの読み書きがボトルネックとなり、遅いイメージができる。<br>
[プロダクションでの活用-Dockerfileのベストプラクティス-]<br>
・オーケストレーションツール:複数のDockerを扱うための技術のこと。<br>
⚫︎軽量なイメージを作る<br>
Docker Image はレイヤーが少なくサイズが軽いものが良いものだとされている。<br>
⚫︎最小限の構成にする<br>
Dockerは1コンテナ1プロセスになるように設計を行うこと。複数のプロセスを使用したい場合はそれぞれコンテナに分け、オーケストレーションツールを使用してコンテナを協調させて動かすようにすること。<br>
⚫︎軽量なベースイメージを使用する<br>
⚫︎.dockerignoreを使う<br>
Dockerのビルド時に無視するファイル/ディレクトリを指定することができる。".git"のようなコンテナ内に不要な情報、"node_modules"のような上書きされると困るものを記述する。.dockerignore は基本的に.gitignoreと同じ書き方が可能。<br>
⚫︎Build<br>
⚫︎キャッシュを意識する<br>
Docker Imageは各コマンド毎にキャッシュを作成する。(これを中間レイヤーと呼ぶ。)ビルド後に、コマンドの変更・ファイルの追加/更新など、なにか変化を起こすと、変化が起こったレイヤーの直前のキャッシュからビルドを実行する。<br>
⚫︎Multi-Stage Build<br>
・バイナリ:コンピュータが直接的に処理するために2進数で表現されるデータのこと。<br>
Multi-Stage Buildは複数のDocker Image を作り、最終的にその複数のDocker Imageから任意のファイルだけを抽出して1つのDocker Imageにする。<br>
例）<br>
```
#==================================================
# Build Layer
FROM golang:1.12-alpine as build

WORKDIR /go/app

COPY . .

RUN apk add --no-cache git \
  && go build -o app

#==================================================
# Run Layer
FROM alpine

WORKDIR /app

COPY --from=build /go/app/app .

RUN addgroup go \
  && adduser -D -G go go \
  && chown -R go:go /app/app

CMD ["./app"]
```
【次やること】
## ☆Docker
⚫︎Docker入門<br>
・入門 Dockerを読む<br>
→プロダクションでの活用-オーケストレーションツール-から<br>
# 【感じたこと】
・レイヤーと似たようなもので中間イメージというものが出てきました。始めは異なる部分がよくわかりませんでしたが、読み進めているうちに異なる部分を理解することができたのでよかったです。<br>
・動画よりも踏み込んだ内容も記載されていることがあるため勉強になりました。<br>
・本日2時間07分<br>
・月合計:55時間13分<br>
・累計:458間07分<br>
