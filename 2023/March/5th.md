## 　2023年3月5日(日)
# 【取り組んだ課題一覧】
## ☆プログラミングに触れてみる
・progateでプログラミングに触れてみよう  
→progateでの学習【学習レッスン Node.js V ~ 2 章：ログイン機能を作ろう(ユーザー認証の処理を作ろう（２）) ~】まで
# 【わかったこと】
## ☆【学習レッスン Node.js II】
・ input要素にname属性を指定すると、オブジェクトの形で情報がサーバーに送信される。よってサーバー側ではreq.body.name属性の値でフォームの値を取得できる。<br>
・フォームの値を受け取るにはapp.jsで下図のソースコードを追加する必要がある。<br>
例）<br>

    :
    app.use(express.urlencoded({extended: false}));
    
    app.post('create', (req, res)=>{
        console.log(req.body.itemName);
        :
    });
・SELECTの時と同様にqueryメソッドを使うことで　INSERTを実行することができる。フォームからの値をクエリに使うときは、VALUESに「?」を含める。次に「connection.query()」の第2引数に渡したい配列を指定する。この配列の要素が「?」の部分に入り、実行される。<br>
例）<br>

    app.post('create', (req, res)=>{
        connection.query(
            'INSERT INTO items(name) VALUES(?)',
            [req.body.itemName],
            (error. results)=>{
                :
            }
        );
    });
・リロードは直前のリクエストを実行する機能である。<br>
・サーバーは「次はこのURLにリクエストしてね」というレスポンスを返すことができる。このレスポンスを受け取ったブラウザは指定されたURLに自動的にリクエストする。このような別のURLに再度リクエストさせる仕組みをリダイレクトという。リダイレクトするにはres.redirectメソッドを用い、引数にURLを指定する。<br>
例）<br>

    app.post('create', (req, res)=>{
        connection.query(
            'INSERT INTO items(name) VALUES(?)',
            [req.body.itemName],
            (error. results)=>{
                res.redirect('/index');
            }
        );
    });
・リダイレクトを使う場面はいくつかあるが、よくあるのは今回のようにpostメソッドでリクエストした時である。こういう時はres.renderではなくres.redirectを使って、getのルーティングにリダイレクトするようにすること。
## ☆【学習レッスン Node.js III】
・postでリクエストする時は入力する項目がなくてもフォームを使うと覚えておくこと。<br>
例）<br>

    <form action="/delete" method="post">
        <input type="submit" value="削除">
    </form>
・削除にはDELETEクエリを使う。<br>
例）<br>

    DELETE FROM items WHERE id=3
・idを受け渡すにはURLを利用する。リクエストするURLは/delete/3のようにidを含めるようにし、ルーティングのURLは/delete/:idのように指定する。これでURLに含まれたidを取得できるようになる。/:idの部分をルートパラメータと呼ぶ。また、req.params.ルートパラメータ名でルートパラメータの値を受け取ることができる。<br>
例）<br>
【index.ejs】

    <form action="/delete/<%= item.id %>" method="post">
    :
    
【app.js】

    app.post('/delete/:id', (req, res)=>{
        console.log(req.params.id);
            res.redirect('/index');
    });
・値が「？」に入る。<br>
例）<br>

    app.post('create', (req, res)=>{
        connection.query(
            'DELETE FROM items WHERE id = ?',
            [req.params.id],
            (error. results)=>{
                res.redirect('/index');
            }
        );
    });
・クエリの取得結果は件数に関わらず配列になる。<br>
例）<br>

        connection.query(
            'SELECT * FROM items WHERE id = ?',
            [req.params.id],
            (error. results)=>{
                res.redirect('edit.ejs', {item: results[0]});
            }
        );
・value属性に値を指定すると、フォームに初期値を表示できる。<br>
例）<br>

    <input value="<%= item.name %>" type="text">
        :
・更新にはUPDATEクエリを使う。<br>
例）<br>

    UPDATE items SET name='とまと' WHERE id=3
・ルートパラメータの値はparamsオブジェクトで、フォームの値はbodyオブジェクトで受け取る。<br>
→idはルートパラメータとparamsで受け渡す<br>
→更新する値はフォームとbodyで受け渡す<br>
・クエリに複数の値を入れる時は配列の要素を増やす。配列の要素の順番通りに？に入れることができる。<br>
例）<br>

    app.post('update/:id', (req, res)=>{
        connection.query(
            'UPDATE items SET name=? WHERE id = ?',
            [req.body.itemName, req.params.id],
            (error. results)=>{
                res.redirect('/index');
            }
        );
    });
## ☆【学習レッスン Node.js IV】
・デバッグ-バグの原因を見つけて直すこと。<br>
・バグ-バグとは意図した通りにプログラムが動かないことをいう。バグによってプログラムの処理が止まることをエラーと呼んだりもする。<br>
・デバッグの手順<br>
①エラーの内容を把握<br>
②原因の予想<br>
③予想を順に確認する<br>
・app.jsに誤りがあると、app.listenでサーバーを立ち上げる際にエラーが発生し、どのURLにもアクセスできなくなる場合がある。<br>
・デバッグの一つの手段として、console.logを使って処理中の値を可視化し原因を特定していく方法は有用である。(追加したconsole.logを削除しておくこと。無条件で出力されるconsole.logを残しておくと不要なログが出力されてしまい、これが積み重なると本当に確認したいログを探しづらくなってしまうため。)
## ☆【より高度なWebアプリケーションを作る準備をしよう！】
・クライアントとサーバーの通信は、クライアントのリクエスト（ request ）を元にサーバーがレスポンス（ response ）を返すという流れになっている。(復習)<br>
・リクエストやレスポンスなど、クライアントとサーバーが通信するときの手順やデータ形式にはルールがある。このルールは、HTTP（Hyper Text Transfer Protocol：ハイパー・テキスト・トランスファー・プロトコル）と呼ばれている。<br>
・HTTPに則った通信には、ステートレス（Stateless）性という性質がある。<br>
・ステートレス性-サーバーがクライアントの状態（state）を保持しない（less）という性質のことである。ステートレス性にはサーバーの処理速度の向上などのメリットがありますが、高度なWebアプリケーションを作るうえでは困ることがある。<br>
例）<br>
①まず１回目の通信でクライアントはログインをリクエストする。そして、サーバーはログインできたとレスポンスを返す。このときクライアントの状態は「ログインしている」となる。<br>
②２回目の通信でクライアントはログイン後に見れるプロフィールページをリクエストする。しかし、サーバーはログインしていないとレスポンスを返す。サーバーはクライアントの状態を保持しないので、このときクライアントの状態は「ログインしていない」となる。<br>
・セッション管理-セッション管理とは、セッション中のクライアントの状態をサーバーが管理することである。セッションとは、通信の始まりから終わりまでを指す。例として、ログインしてからログアウトするまでが、セッションとなる。このセッションの間、「ログインしている」というクライアントの状態をサーバーが管理することがセッション管理に当たる。<br>
・セッション管理の流れ<br>
セッション管理の流れは、以下のように３段階に分けられます。<br>
1. クライアントの状態を登録する（例：ログインする）<br>
    ①. クライアントがサーバーにログインをリクエストする。<br>
    ②. ログインに成功した場合、サーバーは「（クライアントが）ログインしている」という状態をメモリーやデータベースに登録する。<br>
    ③. そのあと、サーバーはクライアントにセッションIDを返す。<br>
    ④. クライアントは、受け取ったセッションIDを保存する。<br>
※クライアントの状態を登録したデータをセッション情報、それに紐づくIDのことをセッションID（Session ID, SID）と呼ぶ。<br>
2. クライアントの状態を確認する（例：プロフィールページを見る）<br>
    ⑤. クライアントは、保存したセッションIDと一緒に、サーバーにプロフィールページをリクエストする。<br>
    ⑥. サーバーは送られてきたセッションIDに紐づくセッション情報を参照し、「（クライアントが）ログインしている」状態であることを確認する。(サーバーはクライアントの状態を復元し、以前の通信の続きとして処理している。)<br>
    ⑦. クライアントの状態を確認できたので、サーバーはクライアントにプロフィールページを返す。<br>
3. クライアントの状態を破棄する（例：ログアウトする）<br>
    ⑧. クライアントがサーバーにログアウトをリクエストする。セッションIDも一緒にサーバーに渡す。<br>
    ⑨. サーバーは、セッションIDに紐づくセッション情報を削除する。<br>
    ⑩. サーバーは、クライアントを適当なページにリダイレクトする。<br>
このようにしてサーバーは、クライアントの状態を登録してから破棄するまで保持する。これがセッション管理の流れである。<br>
・まとめ<br>
1. クライアントとサーバーが通信するときの手順やデータ形式を定めたルールをHTTPと呼ぶ。<br>
2. HTTPに則った通信のステートレス性が問題になる場合がある。ステートレス性とは、サーバーがクライアントの状態を保持しないという性質のことである。<br>
3. ステートレス性の問題を解決する方法のひとつがセッション管理である。セッション管理では、サーバーがクライアントの状態をセッション情報として管理する。管理するときには、セッションIDを用る。<br>
## ☆【学習レッスン Node.js V】
・type属性をpasswordに指定すると力した値が伏字になる。(復習)<br>
# 【次やること】
・progateでの学習【学習レッスン Node.js V ~ 2 章：ログイン機能を作ろう(セッションを管理しよう) ~】
# 【感じたこと】
・Webアプリ上で普段何気なく「リロード」を行なっていましたが、今回学習した内容の中で機能を知ることができました。<br>
・まだ始めからコードを書くことはもちろんできませんが、練習問題で何度も出題された文法は定着してきました。<br>
・デバッグの際に間違えやすそうな箇所にエラーが起こったときに自動で出力するようにしておくと便利そうだと思いました。
# 【学習時間】
・本日:4時間16分<br>
・月合計:18時間29分<br>
・累計:84時間49分
