## 　2023年11月11日(土)
# 【取り組んだ課題一覧】
## ☆Ruby
⚫︎「プロを目指す人のためのRuby入門」を読む(ハンズオン)<br>
→1009/1342まで<br>
⚫︎「プロを目指す人のためのRuby入門」を読む(読みのみ)<br>
→997/1342まで<br>
# 【わかったこと】
[第9章 例外処理を理解する]<br>
・Rubyでは例外も例外クラスのインスタンス(例外オブジェクト)になっている。<br>
・例外が発生した箇所がbegin~rescueで囲まれていない場合、例外が発生するとそこで処理を中断してメソッドの呼び出しを1つずつ戻っていく。<br>
→メソッド呼び出しを戻る途中にその例外を捕捉するコードがあれば、そこから処理を続行できる。<br>
→rescue節を複数書くことで、異なる例外クラスに対応することもできる。また1つのrescue節に複数の例外クラスを指定することもできる。<br>
→rescue節に何もクラスを指定しなかった場合に捕捉されるのはStandardErrorとそのサブクラス。<br>
→ewscue節に例外クラスを指定した場合、捕捉されるのはそのクラス自身とそのサブクラス。<br>
・Rubyでは発生した例外自身もオブジェクトになっている。<br>
→そのため例外オブジェクトのメソッドを呼び出すことで、発生した例外に関する情報を取得することができる。<br>
・messageメソッド:例外発生時のエラーメッセージを返す。<br>
・backtraceメソッド:バックトレース情報(つまりメソッドの呼び出し履歴)を配列にして返す。<br>
・例外オブジェクトを変数に格納することも可能。<br>
・例外処理を書く場合は例外クラスの継承関係を意識すること。<br>
・rescue節でretry文を実行するとbegin節に最初からやり直すことができる。(ネットワークエラーのように一時的に発生している問題が例外の原因の場合)<br>
→無限ループを作ってしまわないようにカウンタ変数を用意してretryの回数を制限するのが良い。<br>
・raiseメソッド:意図的に例外を発生させる。<br>
→raiseメソッドに文字列を渡すとその文字列がエラーメッセージになる。<br>
→第1引数に例外クラスを、第2引数にエラーメッセージを渡すとRuntimeErrorクラス以外の例外クラスで例外を発生させることができる。もしくはraiseメソッドに例外クラスのインスタンスを渡す方法もある。<br>
・getsメソッド:ターミナル上でユーザの入力を受け付ける。このメソッドはKernelモジュールで定義されているメソッドなため、グローバル関数のようにどこでも使える。<br>
ensure:例外が発生してもしなくても必ず実行したい処理がある場合にensureに書くことでどちらの場合でも必ず実行される。<br>
・例外処理には戻り値がある。<br>
→例外が発生せず最後まで正常に処理が進んだ場合はbegin節の最後の式が戻り値になる。また、例外が発生してその例外が捕捉された場合はrescue節の最後の式が戻り値になる。<br>
・ensure節にreturnを書くと正常時も例外発生時もensureの値がメソッドの戻り値になってしまう。<br>
→rescue節をなくしてensure節だけにすると例外の発生自体が取り消されてしまう。(つまり正常終了してしまう。)<br>
・パース:特定の書式に従った文字列を解析し、プログラムで利用可能な別のデータ構造に変換すること。<br>
・rescue修飾子を使うとStandardErrorとそのサブクラスが捕捉される。<br>
→beginとendは省略できるが捕捉する例外クラスを指定することはできない。<br>
・Rubyでは最後の発生した例外は組み込み変数の$!に格納される。また、バックトレース情報は$@に格納される。<br>
・メソッドの中身全体が例外処理で囲まれている場合はbeginキーワードとendキーワードを省略することができる。<br>
・rescue節の中でraiseメソッドを使うこともできる。この時raiseメソッドの引数を省略すると、rescue節で捕捉した例外をもう一度発生させることができる。<br>
・例外クラスは独自に定義することも可能。<br>
→例外クラスを定義する場合は特別な理由がない限り、StandardErrorクラスかそのサブクラスを継承する。<br>
[第10章 yieldとProcを理解する]<br>
・yieldを複数回書けばブロックも複数回呼ばれる。<br>
・yieldはブロックに引数を渡したり、ブロックの戻り値を受け取ったりできる。<br>
・ブロックを引数として受け取る場合は引数名の前に&を付ける。また、そのブロックを実行する場合はcallメソッドを使う。<br>
→ブロックの引数はメソッド定義につき1つしか指定できない。また、他の引数がある場合はブロックの引数を必ず最後に指定する必要がある。<br>
```
⚫︎ブロックを引数にするメリット
①ブロックを他のメソッドに引き渡せるようになること。
②渡されたブロックに対してメソッドを呼び出し必要な情報を取得したり、ブロックに対する何かしらの操作を実行したりできるようになること。
```
・Procクラスはブロックをオブジェクト化するためのクラス。<br>
→Procクラスのインスタンス(Procオブジェクト)を作成する場合はProc.newにブロックを渡す。<br>
→Procオブジェクトを実行したい場合はcallメソッドを使う。<br>
→メソッドが受け取れるブロックの数は最大で1つだが、Procオブジェクトは文字列や数値と同じ「ただのオブジェクト」なため引数として渡すぶんには制限はない。<br>
# 【次やること】
## ☆Ruby
⚫︎「プロを目指す人のためのRuby入門」を読む<br>
→1009/1342から<br>
⚫︎「プロを目指す人のためのRuby入門」を読む(読みのみ)<br>
→997/1342まで<br>
# 【感じたこと】
・本日も引き続きチェリー本でのインプットを行いました。ようやく第10章まで来ました。第9章の例外処理についてはむやみやたらに実装するものではなく、本当に必要な時にのみ実装するべきだということがよくわかりました。
第10章ではまだ途中ですが、ブロックを引数として受け取る場合&を付け、Procオブジェクトを引数として受け取る場合&付けないという部分が少しややこしク感じましたが間違えないように気をつけようと思いました。<br>
・本日05時間00分<br>
・月合計:28時間52分<br>
・累計:584間57分<br>
